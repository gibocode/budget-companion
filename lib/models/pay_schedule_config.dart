/// Policy for including pay periods when retrieving or reporting data by calendar month.
enum MonthInclusionPolicy {
  /// Classify by period start: include period in the month of its [start] date.
  startMonth,
  /// Classify by period end (payroll at period close): include period in the month of its [end] date.
  endMonth,
  /// Accrual-accurate: include overlapping periods and prorate by day-overlap with the target month.
  accrualProrated,
}

/// One recurring period: [start] and [end] are the source of truth; always [periodLengthDays] long (e.g. 14 days).
class PayPeriod {
  const PayPeriod({
    required this.start,
    required this.end,
    required this.indexInMonth,
  });

  final DateTime start;
  final DateTime end;
  final int indexInMonth;

  /// Stable key for this period (yyyy-mm-dd of start). Same period has same key in any month.
  String get periodKey =>
      '${start.year}-${start.month.toString().padLeft(2, '0')}-${start.day.toString().padLeft(2, '0')}';

  bool contains(DateTime d) {
    final day = DateTime(d.year, d.month, d.day);
    final s = DateTime(start.year, start.month, start.day);
    final e = DateTime(end.year, end.month, end.day);
    return !day.isBefore(s) && !day.isAfter(e);
  }

  /// Full period range (always full 14 days), e.g. "Feb 27 – Mar 12".
  String get label {
    final s = '${_monthName(start.month)} ${start.day}';
    final e = '${_monthName(end.month)} ${end.day}';
    return start.month == end.month ? '$s–$e' : '$s – $e';
  }

  static String _monthName(int month) {
    const names = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return names[month - 1];
  }
}

/// Simple pay schedule: fixed anchor date for the first period, then each period is exactly
/// [periodLengthDays] long with no gaps or overlaps. [start] and [end] per period are the source of truth.
class PayScheduleConfig {
  const PayScheduleConfig({
    this.startDate,
    this.periodLengthDays = 14,
  });

  /// Anchor date: first day of the first 14-day period. If null, falls back to calendar month (1–15, 16–end).
  final DateTime? startDate;
  /// Length of each period in days (e.g. 14). Subsequent periods are generated by adding this many days sequentially.
  final int periodLengthDays;

  static String monthName(int month) {
    const names = [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
    ];
    return names[month - 1];
  }

  int lastDayOfMonth(int year, int month) =>
      DateTime(year, month + 1, 0).day;

  /// Periods that overlap the given month. Each period is a full [periodLengthDays] days (no gaps/overlaps).
  List<PayPeriod> periodsForMonth(int year, int month) {
    if (startDate == null) {
      return _periodsCalendarMonth(year, month);
    }
    return _periodsFromStartDate(year, month);
  }

  /// Periods to include when retrieving data for calendar month (year, month) under [policy].
  /// - [MonthInclusionPolicy.startMonth]: periods whose start date falls in that month.
  /// - [MonthInclusionPolicy.endMonth]: periods whose end date falls in that month (payroll at period close).
  /// - [MonthInclusionPolicy.accrualProrated]: all periods that overlap the month (prorate via [prorateWeightsForMonth]).
  List<PayPeriod> periodsIncludedInMonth(
    int year,
    int month,
    MonthInclusionPolicy policy,
  ) {
    final overlapping = periodsForMonth(year, month);
    switch (policy) {
      case MonthInclusionPolicy.startMonth:
        return overlapping
            .where((p) => p.start.year == year && p.start.month == month)
            .toList();
      case MonthInclusionPolicy.endMonth:
        return overlapping
            .where((p) => p.end.year == year && p.end.month == month)
            .toList();
      case MonthInclusionPolicy.accrualProrated:
        return overlapping;
    }
  }

  /// For accrual reporting: periodKey -> fraction of that period falling in (year, month).
  /// Fraction = overlapDays(period, month) / periodLengthDays. Only includes periods that overlap the month.
  Map<String, double> prorateWeightsForMonth(int year, int month) {
    final periods = periodsForMonth(year, month);
    final map = <String, double>{};
    for (final p in periods) {
      final overlap = _overlapDays(p.start, p.end, year, month);
      if (overlap > 0) {
        map[p.periodKey] = overlap / periodLengthDays;
      }
    }
    return map;
  }

  static int _overlapDays(DateTime periodStart, DateTime periodEnd, int year, int month) {
    final monthStart = DateTime(year, month, 1);
    final lastDay = DateTime(year, month + 1, 0).day;
    final monthEnd = DateTime(year, month, lastDay);
    final pStart = DateTime(periodStart.year, periodStart.month, periodStart.day);
    final pEnd = DateTime(periodEnd.year, periodEnd.month, periodEnd.day);
    final start = pStart.isBefore(monthStart) ? monthStart : pStart;
    final end = pEnd.isAfter(monthEnd) ? monthEnd : pEnd;
    if (start.isAfter(end)) return 0;
    return end.difference(start).inDays + 1;
  }

  List<PayPeriod> _periodsCalendarMonth(int year, int month) {
    final lastDay = lastDayOfMonth(year, month);
    final monthStart = DateTime(year, month, 1);
    final monthEnd = DateTime(year, month, lastDay);
    final d = 15.clamp(1, lastDay);
    if (d <= 1) {
      return [PayPeriod(start: monthStart, end: monthEnd, indexInMonth: 1)];
    }
    final p1End = DateTime(year, month, d - 1);
    final p2Start = DateTime(year, month, d);
    return [
      PayPeriod(start: monthStart, end: p1End, indexInMonth: 1),
      PayPeriod(start: p2Start, end: monthEnd, indexInMonth: 2),
    ];
  }

  List<PayPeriod> _periodsFromStartDate(int year, int month) {
    final lastDay = lastDayOfMonth(year, month);
    final monthStart = DateTime(year, month, 1);
    final monthEnd = DateTime(year, month, lastDay);

    var periodStart = DateTime(
      startDate!.year,
      startDate!.month,
      startDate!.day,
    );
    while (periodStart.add(Duration(days: periodLengthDays)).isBefore(monthStart)) {
      periodStart = periodStart.add(Duration(days: periodLengthDays));
    }

    final List<PayPeriod> result = [];
    int index = 1;
    while (periodStart.isBefore(monthEnd) || periodStart.isAtSameMomentAs(monthEnd)) {
      final periodEnd = periodStart.add(Duration(days: periodLengthDays - 1));
      if (!periodEnd.isBefore(monthStart)) {
        result.add(PayPeriod(
          start: periodStart,
          end: periodEnd,
          indexInMonth: index,
        ));
        index++;
      }
      periodStart = periodStart.add(Duration(days: periodLengthDays));
    }
    return result;
  }

  int periodForDay(int year, int month, int day) {
    final d = DateTime(year, month, day);
    final periods = periodsForMonth(year, month);
    for (final p in periods) {
      if (p.contains(d)) return p.indexInMonth;
    }
    return 0;
  }

  int periodIndexForDate(DateTime date) {
    final periods = periodsForMonth(date.year, date.month);
    for (final p in periods) {
      if (p.contains(date)) return p.indexInMonth;
    }
    return 0;
  }

  /// The pay period that contains [date], if any. For custom schedules, checks
  /// the configured recurring periods starting from [startDate]. For calendar
  /// month fallback (no custom schedule), uses simple 1–15 / 16–end periods.
  PayPeriod? periodContaining(DateTime date) {
    final day = DateTime(date.year, date.month, date.day);

    // If no custom start date is configured, fall back to the simple
    // calendar-based split (1–15, 16–end).
    if (startDate == null) {
      for (final p in _periodsCalendarMonth(day.year, day.month)) {
        if (p.contains(day)) return p;
      }
      return null;
    }

    final anchor = DateTime(startDate!.year, startDate!.month, startDate!.day);
    if (day.isBefore(anchor)) return null;

    final daysFromAnchor = day.difference(anchor).inDays;
    final periodsFromAnchor = daysFromAnchor ~/ periodLengthDays;
    final periodStart = anchor.add(Duration(days: periodsFromAnchor * periodLengthDays));
    final periodEnd = periodStart.add(Duration(days: periodLengthDays - 1));

    if (day.isBefore(periodStart) || day.isAfter(periodEnd)) {
      return null;
    }

    // Derive indexInMonth by looking at all periods for that month and
    // matching on the start date.
    final monthPeriods = periodsForMonth(periodStart.year, periodStart.month);
    final idx = monthPeriods.indexWhere((p) =>
        p.start.year == periodStart.year &&
        p.start.month == periodStart.month &&
        p.start.day == periodStart.day);
    final indexInMonth = idx >= 0 ? monthPeriods[idx].indexInMonth : 1;

    return PayPeriod(
      start: periodStart,
      end: periodEnd,
      indexInMonth: indexInMonth,
    );
  }

  /// (year, month) to use as default month selector, based on the pay period
  /// containing [date], and the month-inclusion policy chosen in Settings →
  /// Pay period.
  ///
  /// - [MonthInclusionPolicy.startMonth]: month of the period start.
  /// - [MonthInclusionPolicy.endMonth]: month of the period end.
  /// - [MonthInclusionPolicy.accrualProrated]: calendar month of [date]
  ///   (period is split across months, so we stick with today's month).
  (int year, int month) defaultMonthForDate(DateTime date, MonthInclusionPolicy policy) {
    final p = periodContaining(date);
    if (p == null) return (date.year, date.month);
    switch (policy) {
      case MonthInclusionPolicy.startMonth:
        return (p.start.year, p.start.month);
      case MonthInclusionPolicy.endMonth:
        return (p.end.year, p.end.month);
      case MonthInclusionPolicy.accrualProrated:
        // For accrual/prorated reporting, the period contributes to each
        // overlapping calendar month. For the default selector we keep
        // using the current calendar month where [date] falls.
        return (date.year, date.month);
    }
  }

  String period1DateRange(int year, int month) {
    final periods = periodsForMonth(year, month);
    if (periods.isEmpty) return '${monthName(month)} 1–${lastDayOfMonth(year, month)}';
    return periods.first.label;
  }

  String period2DateRange(int year, int month) {
    final periods = periodsForMonth(year, month);
    if (periods.length < 2) {
      final last = lastDayOfMonth(year, month);
      return '${monthName(month)} 1–$last';
    }
    return periods[1].label;
  }

  String labelForPeriod(PayPeriod p) => p.label;

  /// Ordered list of period keys from [anchorPeriodKey] (yyyy-mm-dd) forward, for about [yearsAhead] years.
  /// Used to resolve recurring budgets (interval and maxCount).
  List<String> periodKeysFromAnchor(String anchorPeriodKey, {int yearsAhead = 10}) {
    final parts = anchorPeriodKey.split('-');
    if (parts.length != 3) return [];
    final y = int.tryParse(parts[0]);
    final m = int.tryParse(parts[1]);
    final d = int.tryParse(parts[2]);
    if (y == null || m == null || d == null) return [];
    var periodStart = DateTime(y, m, d);
    final end = DateTime(periodStart.year + yearsAhead, 12, 31);
    final List<String> keys = [];
    while (periodStart.isBefore(end) || periodStart.isAtSameMomentAs(end)) {
      keys.add(
        '${periodStart.year}-${periodStart.month.toString().padLeft(2, '0')}-${periodStart.day.toString().padLeft(2, '0')}',
      );
      periodStart = periodStart.add(Duration(days: periodLengthDays));
    }
    return keys;
  }
}
